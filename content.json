{"meta":{"title":"时光-流沙","subtitle":null,"description":null,"author":"Lee","url":"https://leejaywell.github.io/blog"},"pages":[{"title":"about me","date":"2017-09-04T09:54:01.730Z","updated":"2017-09-04T09:54:01.730Z","comments":true,"path":"about/index.html","permalink":"https://leejaywell.github.io/blog/about/index.html","excerpt":"","text":"Java程序员"},{"title":"timeline","date":"2017-09-04T08:48:42.504Z","updated":"2017-09-04T08:48:42.504Z","comments":true,"path":"timeline/index.html","permalink":"https://leejaywell.github.io/blog/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"Music","slug":"Music","date":"2018-06-04T06:52:21.000Z","updated":"2018-06-04T07:14:33.950Z","comments":true,"path":"2018/06/04/Music/","link":"","permalink":"https://leejaywell.github.io/blog/2018/06/04/Music/","excerpt":"","text":"云烟成雨","categories":[],"tags":[]},{"title":"Json Web Token","slug":"Json-Web-Token","date":"2018-06-04T03:10:19.000Z","updated":"2018-06-04T06:41:09.464Z","comments":true,"path":"2018/06/04/Json-Web-Token/","link":"","permalink":"https://leejaywell.github.io/blog/2018/06/04/Json-Web-Token/","excerpt":"","text":"1. 定义JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（RFC 7519），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库。 2. JWT的结构JWT包含了使用.分隔的三部分：Header 头部Payload 负载Signature 签名 结构看起来是这样的Header.Payload.Signature 2.1 Headerheader中通常包含了两部分：token类型和采用的加密算法。{ “alg”: “HS256”, “typ”: “JWT”}这部分内容使用Base64Url编码组成了JWT结构的第一部分。 2.2 PayloadToken的第二部分是负载，它包含了claim，Claim是一些实体（通常指的用户）的状态和额外的元数据，有三种类型的claim：reserved, public 和 private.Reserved claims: 这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有 iss（签发者）,exp（过期时间戳）, sub（面向的用户）, aud（接收方）, iat（签发时间）。Public claims：根据需要定义自己的字段，注意应该避免冲突Private claims：这些是自定义的字段，可以用来在双方之间交换信息负载使用的例子：{ “sub”: “1234567890”, “name”: “John Doe”, “admin”: true} 负载需要经过Base64Url编码后作为JWT结构的第二部分。 2.3 Signature创建签名需要使用编码后的header和payload以及一个秘钥，使用header中指定签名算法进行签名。例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建： 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 3. 使用场景 1、用于向Web应用传递一些非敏感信息。例如完成加好友、下订单的操作等等。 2、用于设计用户认证和授权系统。 3、实现Web应用的单点登录。 3.1 实例场景在A用户关注了B用户的时候，系统发邮件给B用户，并且附有一个链接“点此关注A用户”。链接的地址： https://your.awesome-app.com/make-friend/?from_user=B&amp;target_user=A 让B用户不用登录就可以完成这个操作。 3.2 登陆场景在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保证一个session，当然会给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。 cookie+session这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题，随着用户量的增多，开销就会越大。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。","categories":[],"tags":[]},{"title":"Java基础之ClassLoader","slug":"Java-ClassLoader","date":"2017-09-30T06:32:45.000Z","updated":"2018-01-23T02:47:19.007Z","comments":true,"path":"2017/09/30/Java-ClassLoader/","link":"","permalink":"https://leejaywell.github.io/blog/2017/09/30/Java-ClassLoader/","excerpt":"","text":"Java基础之ClassLoader1.1 简介开发人员对Java.lang.ClassNotFoundExeption这个异常肯定都不陌生，想要详细了解和解决这个问题， 这涉及到Java技术体系中的类加载技术。Java的类加载机制是其体系中比较核心的部分，虽然和大部分开发人员直接打交道不多，但是对其背后的有一定的理解有助于排查程序中出现类加载失败等技术问题，对于理解Java虚拟机的连接模型和 Java语言的动态性都有很大的帮助。 1.2 常见异常 Java.lang.ClassNotFoundExeption Java.lang.NoClassDefFoundError Java.lang.NoSuchMethodError Java.lang.ClassCastException Java.lang.LinkageError 1.3 class加载过程 装载：通过类的全限定名获取二进制字节流，将二进制流转换成方法去中的运行时数据结构，在内存中生成java.lang.Class对象。 链接： 校验：检查导入类或接口的二进制数据的正确性（文件格式验证，元数据验证，字节码验证，符号引用验证） 准备：给类的静态变量分配并初始化存储空间 解析：将常量池中的符号引用转换成直接引用 初始化：激活类的静态变量,初始化代码块和静态代码块，并初始化程序设置的变量值。 1.3.1 类的主动使用 遇到new,getstatic,putstatic,invokestatic这四条字节码指令 创建类的实例 访问某个类或接口的静态变量，或者对静态变量赋值 调用某个类的静态方法 反射( 如Class.forName(“”) ) 初始化一个类的子类 Java虚拟机启动时被表明为启动类的类(Java Test) 1.3.2 分析Class.forName()和ClassLoader.loadClass() Class.forName(className)方法，内部实际调用的方法是Class.forName(className,true,classLoader),第二个参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。这表示会触发目标类的static变量和static代码块会被再次初始化。 ClassLoader.loadClass(className)方法，内部实际调用的是它的重载方法ClassLoader.loadClass(className,false);第二参数表示目标对象是否进行链接，false表示不进行链接，不链接就意味着不进行包括初始化等一系列步骤，所以静态变量和静态代码块就不会的到执行。 1.4 ClassLoader结构简述JVM中预定义了三种类加载器，当一个JVM实例启动的时候，JVM缺省开始使用如下三种类型的类加载器： 启动（Boostrap）类加载器：引导类装载器是由本地代码实现的类加载器，其负责/lib下面的核心类库或者可以使用 jvm参数-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节， 开发者无法直接获取到启动类加载的引用，所以不允许直接引用进行操作。扩展（Extension）类加载器：扩展类加载是由Sun的ExtClassLoader（Sun.misc.Launcher$ExtClassLoader）实现的。其负责 将/lib/ext或者由JVM参数-Djava.ext.dir指定位置中的类加载到内存中。开发者可以直接使用标准扩展类记载其。系统（System）类加载：系统类加载器是由Sun的AppClassLoader（Sun.misc.Launcher$AppClassLoader）是实现的。 其负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统加载器。 除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器 关系图 1.5 ClassLoader加载机制JVM在加载类的时候默认是采用的是双亲委派机制，通俗的说，就是某个特定的类加载器在接到类加载的请求时，首先将加载的任务委托给父类加载器，依次类推，如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成此加载任务时，才自己去加载。 对于这种加载机制，可以从系统类加载器和扩展类加载器为例简单分析： 1.扩展类加载器继承关系图 2.系统类加载器继承关系图 1.6 类加载器的并行加载和单例模式 其实都是通过定义静态的成员变量，以保证instance可以在类初始化的时候被实例化。那为啥让instance在类初始化的时候被实例化就能保证线程安全了呢？因为类的初始化是由ClassLoader完成的，这其实就是利用了ClassLoader的线程安全机制啊。再说静态内部类，这种方式和饿汉方式只有细微差别，只是做法上稍微优雅一点。这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。但是，原理和饿汉一样。 1.7 热加载 在 Java 开发领域，热加载一直是一个难以解决的问题，从JDK1.4提供的技术，运行开发人员在debug过程中能够立即重载修改后的class。所有的IDE都支持这个特性（Intellij IDEA，Eclipse，NetBeans)。如果debug应用，并且修改了某些class，jvm会立即载入修改后的class。同样，这个技术也有限制：只允许修改方法体，不允许增加新的class、不允许新增字段、不允许新增方法、不允许修改方法签名。对于整个类的结构修改，仍然需要重启虚拟机，对类重新加载才能完成更新操作。对于某些大型的应用来说，每次的重启都需要花费大量的时间成本。 什么是热加载 12在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例 尝试方案： 把原来的类信息卸载掉，然后重新加载此类 新建一个类加载器（new），重新加载此类，不管原来的类信息，等待垃圾回收它 问题： 1.改变加载机制? 12默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。 2.是不是所有的类都能进行热加载呢？ 12我们程序的入口类都是系统类加载器加载的，也就是AppClassLoader加载的。当你重新使用系统类加载器加载这个类的时候是不会被重新加载的。因为虚拟机会检测这个类是否被加载过，如果已经被加载过，那么就不会重新加载。所以由系统类加载器加载的类，是不能进行热加载的。只有使用我们自定义的类加载器加载的类才能热加载。 3.自定义类加载器类有什么问题？ 1234目前的加载机制，称为双亲委派，系统在使用一个 classloader 来加载类时，会先询问当前 classloader 的父类是否有能力加载，如果父类无法实现加载操作，才会将任务下放到该 classloader 来加载。这种自上而下的加载方式的好处是，让每个 classloader 执行自己的加载任务，不会重复加载类。但是这种方式却使加载顺序非常难改变，让自定义 classloader 抢先加载需要监听改变的类成为了一个难题。虽然无法抢先加载该类，但是仍然可以用自定义 classloader 创建一个功能相同的类，让每次实例化的对象都指向这个新的类。当这个类的 class 文件发生改变的时候，再次创建一个更新的类，之后如果系统再次发出实例化请求，创建的对象讲指向这个全新的类。同一个类加载器无法同时加载两个相同名称的类，由于不论类的结构如何发生变化，生成的类名不会变，而 classloader 只能在虚拟机停止前销毁已经加载的类，这样 classloader 就无法加载更新后的类了 javaagent除了做字节码上面的修改之外，其实还有一些小功能，有时候还是挺有用的获取所有已经被加载的类：Class[] getAllLoadedClasses();获取所有已经初始化了的类： Class[] getInitiatedClasses(ClassLoader loader);获取某个对象的大小： long getObjectSize(Object objectToSize);将某个jar加入到bootstrap classpath里优先其他jar被加载： void appendToBootstrapClassLoaderSearch(JarFile jarfile);将某个jar加入到classpath里供appclassloard去加载：void appendToSystemClassLoaderSearch(JarFile jarfile);设置某些native方法的前缀，主要在找native方法的时候做规则匹配： void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix)。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-30T01:12:05.732Z","updated":"2017-09-30T06:51:08.757Z","comments":true,"path":"2017/08/30/hello-world/","link":"","permalink":"https://leejaywell.github.io/blog/2017/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}