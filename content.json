{"meta":{"title":"时光-流沙","subtitle":null,"description":null,"author":"Lee","url":"https://leejaywell.github.io/blog"},"pages":[{"title":"about me","date":"2017-09-04T09:54:01.730Z","updated":"2017-09-04T09:54:01.730Z","comments":true,"path":"about/index.html","permalink":"https://leejaywell.github.io/blog/about/index.html","excerpt":"","text":"Java程序员"},{"title":"timeline","date":"2017-09-04T08:48:42.504Z","updated":"2017-09-04T08:48:42.504Z","comments":true,"path":"timeline/index.html","permalink":"https://leejaywell.github.io/blog/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"Java基础之ClassLoader","slug":"Java-ClassLoader","date":"2017-09-30T06:32:45.000Z","updated":"2017-09-30T06:51:19.645Z","comments":true,"path":"2017/09/30/Java-ClassLoader/","link":"","permalink":"https://leejaywell.github.io/blog/2017/09/30/Java-ClassLoader/","excerpt":"","text":"Java基础之ClassLoader1.1 简介开发人员对Java.lang.ClassNotFoundExeption这个异常肯定都不陌生，想要详细了解和解决这个问题， 这涉及到Java技术体系中的类加载技术。Java的类加载机制是其体系中比较核心的部分，虽然和大部分开发人员直接打交道不多，但是对其背后的有一定的理解有助于排查程序中出现类加载失败等技术问题，对于理解Java虚拟机的连接模型和 Java语言的动态性都有很大的帮助。 1.2 ClassLoader结构简述JVM中预定义了三种类加载器，当一个JVM实例启动的时候，JVM缺省开始使用如下三种类型的类加载器： 启动（Boostrap）类加载器：引导类装载器是由本地代码实现的类加载器，其负责/lib下面的核心类库或者可以使用 jvm参数-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节， 开发者无法直接获取到启动类加载的引用，所以不允许直接引用进行操作。扩展（Extension）类加载器：扩展类加载是由Sun的ExtClassLoader（Sun.misc.Launcher$ExtClassLoader）实现的。其负责 将/lib/ext或者由JVM参数-Djava.ext.dir指定位置中的类加载到内存中。开发者可以直接使用标准扩展类记载其。系统（System）类加载：系统类加载器是由Sun的AppClassLoader（Sun.misc.Launcher$AppClassLoader）是实现的。 其负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统加载器。 除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器 关系图 1.3 ClassLoader加载机制JVM在加载类的时候默认是采用的是双亲委派机制，通俗的说，就是某个特定的类加载器在接到类加载的请求时，首先将加载的任务委托给父类加载器，依次类推，如果父类加载器可以完成类加载任务，就成功返回，如果父类加载器无法完成此加载任务时，才自己去加载。 对于这种加载机制，可以从系统类加载器和扩展类加载器为例简单分析： 1.扩展类加载器继承关系图 2.系统类加载器继承关系图 1.4 class加载过程 装载：通过类的全限定名获取二进制字节流，将二进制流转换成方法去中的运行时数据结构，在内存中生成java.lang.Class对象。 链接： 校验：检查导入类或接口的二进制数据的正确性（文件格式验证，元数据验证，字节码验证，符号引用验证） 准备：给类的静态变量分配并初始化存储空间 解析：将常量池中的符号引用转换成直接引用 初始化：激活类的静态变量,初始化代码块和静态代码块，并初始化程序设置的变量值。 1.4.1 类的主动使用 创建类的实例 访问某个类或接口的静态变量，或者对静态变量赋值 调用某个类的静态方法 发射( 如Class.forName(“”) ) 初始化一个类的子类 Java虚拟机启动时被表明为启动类的类(Java Test) 1.4.2 分析Class.forName()和ClassLoader.loadClass() Class.forName(className)方法，内部实际调用的方法是Class.forName(className,true,classLoader),第二个参数表示类是否需要初始化，Class.forName(className)默认是需要初始化。这表示会触发目标类的static变量和static代码块会被再次初始化。 ClassLoader.loadClass(className)方法，内部实际调用的是它的重载方法ClassLoader.loadClass(className,false);第二参数表示目标对象是否进行链接，false表示不进行链接，不链接就意味着不进行包括初始化等一系列步骤，所以静态变量和静态代码块就不会的到执行。 javaagent除了做字节码上面的修改之外，其实还有一些小功能，有时候还是挺有用的 获取所有已经被加载的类：Class[] getAllLoadedClasses(); 获取所有已经初始化了的类： Class[] getInitiatedClasses(ClassLoader loader); 获取某个对象的大小： long getObjectSize(Object objectToSize); 将某个jar加入到bootstrap classpath里优先其他jar被加载： void appendToBootstrapClassLoaderSearch(JarFile jarfile); 将某个jar加入到classpath里供appclassloard去加载：void appendToSystemClassLoaderSearch(JarFile jarfile); 设置某些native方法的前缀，主要在找native方法的时候做规则匹配： void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix)。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-30T01:12:05.732Z","updated":"2017-09-30T06:51:08.757Z","comments":true,"path":"2017/08/30/hello-world/","link":"","permalink":"https://leejaywell.github.io/blog/2017/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}